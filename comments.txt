init -y 

src - server.ts

typescript, types/node, tsx, tsup -d

npx tsc --init   - tsconfig.json es2020

fastify

server.ts e app.ts

.gitignore

scripts

"scripts": {
    "dev": "tsx watch src/server.ts", - p startar em desenvolvimento, transformando ts em js rapidinho
    "start": "node build src/server.js", - startar pra producao - executar node e executar servidor na 
    pasta js dentro da pasta build
    "build": "tsup src --out-dir build" - pega codigo no src, converte js e joga no /build
  },

  _____________________________________________________________

.npmrc - save-exact=true

com isso, permite fixar as versões exatas das dependências instaladas em um projeto. 
Isso garante a estabilidade e consistência do ambiente de desenvolvimento e produção, 
prevenindo problemas de compatibilidade e incompatibilidade entre as versões das dependências. 
Além disso, esta configuração ajuda a evitar problemas de segurança, pois impede a 
instalação de versões vulneráveis das dependências.


_____________________________________________________________


vasriaveis ambiente:

variaveis que teremos informacoes diferentes, valores diferentes dado o ambiente da nossa aplciacao,
se estiver executando em testes, producao, desenvovimento, stagiing, essas variaveis podem ter valores
diferentes.

.env com essas variaveis
.env.example p qnd aguem baixar o projeto, ela saber qquais variaveis ela precisa setar,
ate pq o .env vai pro .gitignore

-pra carregar essas variaveis ambiente dentro do projeto - 

npm i dotenv - faz o parse, carrega o arquivo .env e transforma em variaveis ambiente
dentro do node que conseguimsoa cessar via process.env.NODE_ENV

-pra fazer o carregamento de umm jeito mais charmoso, nao tao bruto, tentando acessar
diretamente o process.env:

src/env/index.ts

nesse arquivo, inves de apenas carregar as variaveis ambiente com import dotenv/config, 
tbm vms validar as variaveis ambiente, pois tem variaveis de ambiente na nossa aplicacao que sao
obrigatorias estarem existindo no momento que executamos/iniciamos a nossa apliciacao, por exemplo,
pra aplicacao ser inicializada, tem que ter uma url de banco de dados setada

npm i zod

schema p validar, os 3 ambientes sao:
 dev, test e production, um enum, botamos ate um valor default
 port tbm, z.coerce.number(), caso o valor da porta veio com string, 
 nao tem problema, o coerce transfortma em number. tbm podmos botar default.

 validando - schema.safeParse(process.env)
-isso ve se o process.env corresponde ao schema que fizemos anteriormente.

pra ver se validou ou nao, podemos pegar o resultado desse safeParse.
se for false o _env.success, entao pegamos o _env.error e printamos de forma formatadinha

e lancamos um thhrow error pra parar a aplicacao toda.

se a _env.success foi true, entao exportamos essa variavel privada
export const env = _env
agora podemos usar em qlqr lugar da aplicacao o env.PORT ou env.NODE_ENV

_____________________________________________________________

eslint da rocketseat

npm i eslint @rocketseat/eslint-config -D

criamos a pasta .eslintrc.json p ccolcoar o extends de node.

queremos que esse eslint ignore algumas pastas como build e node_modules.
entao criar 
.eslintignore


_____________________________________________________________
no tsconfig.json:

"baseUrl": "./", 
"paths": {
  "@/*": ["./src/*"]
},  

se tivermos la no escafundoh do judas, se quisermos pegar algo la de fora,
inves de fazer../../../../, podemos tacar um @ logo.


_____________________________________________________________

Fundamentos do Prisma ORM

2a camada - query builders, tipo knex

knex converte pra sql, executa aquela query no nosso banco de dados mas nao tem controle do tipo, 
saber se realmente aquela tabela existe no banco de dados, nois temos que fazer  atipagem dele na mao.
e ai teria que informar tanto a nivel de banco de dados quanto na nossa aplicacao essas coisas do tipo,
os tipos, opcional ou nao, etc.

3o nivel de abstracao - maior - ORMs

prisma, typeorm, sequelize.

prisma ehh o melhor pq diminui muito o trabalho que a gente tem principalmente na parte de duplicidade.
integracao mt boa com typescript. Se temos uma tabela users e tem 10 campos, o prisma compreende a existencia da tabela
e deduz de forma automatizada, a tabela, os campos, e no mesmo momentos que estamos digitando, o prisma consegue te avisar
se tem algo errado ou nao. Migrations tbm sao automatizados. Nao precisamos escrever as migrations tipo: arquivo especifico
pra adicionar coluna na tabela. Apenas precisamos alterar o arquiovo que repreesenta a estrutura no banco de dados
e o prisma automaticamente faz a migration.


npm i prisma -D

instalar em desenvolvimento pois, apesar de usarmos o banco de dados em producao, esse prisma que estamos instalando ainda nao eh 
nao eh o carinhha que faz o acesso ao banco, ehh apenas uma interface de lina de comando

npx prisma init

isso inicializa a parte de conexao com banco de daods na nossa aplicacao

o arquivo schema.prisma vai ser uma represenatacao das tabelas que vamos ter no banco de dados.

mongo chama de colection, sql chama de table, entao no prismo a gente chama de MODEL

nosso primeiro model no schema.prisma:

model User {
  id    String @id @default(uuid())
  name  String
  email String @unique

  @@map("users")
}

esse @@map("users)
eh so pra renomear a tabela la no banco pra seguirmos o
padrao de letra minusucla e plural.
o @ unico ja se refere a tal coluna
o @@ juntos se referem a tabela como um todo.

npx prisma generate

eai, podemos ver la no node_modules, no prisma, o arquivo index.d.ts,
la aparece a tipagem desse User, (export type), tbm aparece varios
metodos feitos automaticamente como findByUnique, que no caso podemos
usar com o id e o email, etc.

-agora pra trabalhar de fato com o prisma, temos que instalar o 

npm i @prisma/client

esse sim eh dependencia de producao, pois ehh ele que vms usar pra ACESSAR o banco de dados.

dessa forma, veja o seguinte exemplo:


dps de instanciarmos o PrismaClient() como "prisma",

prisma.user.create({
  data: {
    name: 'Rodrigo',
    email: 'rodrigo@prisma.com',
  },
})

tudo tipado certinho, nao podemos colocar number no lugar de string, tudo tem sugestao de acordo com
a tipagem....prisma eh lgl dms

_____________________________________________________________

postgres com docker

meu coker ta no WSL.

docker run --name api_node_solid_pg bitnami/postgresql
esse ehh o comando, mas vms fzr umas configuracoezinhahs antes de rodar o comando

docker run --name api_node_solid_pg -e POSTGRESQL_USERNAME=docker -e POSTGRESQL_PASSWORD=docker 
-e POSTGRESQL_DATABASE=apisolid -p 5432:5432 bitnami/postgresql

pronto !

se dermos um stop (crtl c), o docker manteve esse container em cache, entao conseguimos subir ela de novo

se rodar docker ps, aparece todos os container atuais rodando
se rodar docker ps -a, mostra todos os container que ja criamos em algum momento.

se quisermos startar aquele nosso container, so colocar:
  - docker start api_node_solid_pg
que foi o nome que
a gente deu na criacao do container inicialmente.

e pra desligar o container:
  - docker stop api_node_solid_pg


no .env, o prisma ja colocou automaticamente isso:

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

alteramos para

DATABASE_URL="postgresql://docker:docker@localhost:5432/apisolid?schema=public"


---testando que o container e o postgres esta funcionando.:

npx prisma migrate dev - esse comando roda a migration.
Como eh a primeira vez que rodamos e apenas criamos a 
tabela User(users), entao o terminal vai perguntar o nome
dessa migratione  a gente coloca simplesmente create users.

a mensagem que aparece:

migrations/
  └─ 20240518220953_create_users/
    └─ migration.sql

Your database is now in sync with your schema.

beekeeper? posticon? NADA DISSO ! o prisma tem o prisma studio

reda@DESKTOP-2NS8NO9:/mnt/c/documentos/projetos/web/rocketseat/formacao_node/api-solid-03$ npx prisma studio
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Prisma Studio is up on http://localhost:5555

ao rodar:
-  npx prisma studio
conseguimos ter acesso ao banco, as tabelas, de forma facil em uma interface


_____________________________________________________________




docker compose - bota aquelas informacoes que usammos no inicio da criacao do container,
e quem usar a nossa aplicacao eh so rodar:\

 docker compose up -d

(-d em modo background, sem 
mostrar os logs por exemplo.)

pra DELETAR o container e os bancos de dados:

 docker compose down

 pra apenas stoppar o container:

 docker compose stop


se deletar tudo ou algo do tipo, lembrar de roda as migrations de novo.


_____________________________________________________________

criando schema com 

vms criar as tabelas de acordo com os requisitos funcionais.
percebe-se nos req. funcionais que ha entidades que aparecem comumente, 
como academias, usuarios, check-ins, que sao entitades que com certeza
teremos que persistir em alguma estrutura de dados, provavelmente 
banco de dados

models p checkin e gym.

gym vai ter latitude e longidutde obrigatorio por motivos de seguranca,
por ex pra evitar chheckin por outra pessoa, ou checkar muito longe, ou usar 2
celulares, esses tipos de coisas

o validated_at no checkin ta mais interessante do que um booleano is_validated,
porque eh como se fosse um atributo q fala duas coisas, se existir, alem de falar
que tem chheckin, ainda fala a data exata.

ao fzr essas mudancas no schema.prisma, so dar o migrate dev.

_____________________________________________________________


RELACIONAMENTOS.

ainda nao fizemos as chaves estrangeiras.

repare que na tabela de check-ins precismaos colocar 
as chaves erstrangeiras referentes a user e gym, pois
um checkin foi feito por um usuario e um checkin foi 
feito em uma academia.

no caso, seria entao user_id String e gym_id String.
mas dessa forma o prisma nao vai saber que existe tal
relacionamento. 

vamos colocar entao user User na tabela de checkin.
ao darmos ENTER, ja que estamos com a extensao do prisma, e
ja que estamso com aquele onSave true no json config,
entao automaticamente sera criado a linha:

user    User   @relation(fields: [user_id], references: [id])

que diz que o campo user_id se refere ao id do User. 

usamos user_id e gym_id por padrao.
e no caso do checkIns, usamso common case como padrao.
pois vamos usar isso no codigo javascript.

-no prisma studio podemos manipular essas foreign keys tbm, 
podemos setar um usuario praquele checkin, ou um gym praquele checkin,
etc.

_____________________________________________________________

primeiramente, pra testar, foi feito um insert basico. 

no app.ts, um app.post simples

que faz:
validacao do body 
criacao do usuario no banco com os dados.

o que foi feito tambem - tiramos a instancia do prisma e
fizemos em outro arquivo /lib/prisma.ts

nesse arquivo, alem de fazer a instanciacao do PrismaClient
e exportar ele pra aplicacao inteira, tbm ativamos o "log",
para, caso estejamos em ambiente de dev, os logs mostrem
as querys que o prisma faz automaticcamente quando mandamos.

por exemplo, no nosso prisma.user.create({}), aconteceu um log,
'INSERT INTO .....'


_____________________________________________________________

Iremos organziar melhor nosso codigo, mas tenha em mente que nao eh
criar mais pastas que vai deixar nosso codigo mais escalavel e manuntenviel.
Mas esse eh o proposito.

Controller eh  um nome dado pra essa funcao que fizemos agora.
Uma funcao que lida com entrrada e saida de dados


a funcao dentro da rota, vira uma funcao exportada na pasta controllers.
a rota que estava em app.ts, jogamos em outra arquivo, que eh uma
funcao exportada contendo todas as rotas. e no app simpelsmente registramos
essa rotas com app.register

ou seja, no app.ts registramos as rotas.
nas rotas, tem cada rota com o controller sendo chamado
nos controllers, tem as regras de negocio.

jaja vms desestrutruar tambem esse controller.

_____________________________________________________________

npm i bcryptjs - para criptografar senha
npm i -D @types/bcryptjs - para tipar, pois a lib eh em js

import { hash } from 'bcryptjs'

criamos o password_hash com base no password,
hash(passowrd, 6)

com isso, o resultado eh criptografado, 6 rounds
significa 6 rodadas de criptografia, mt bom.

eai, passamos esse resultado pro parametro da senha 
no metodo de criar usuario no prisma.
repare que como o name, email e password_hash sao o nome
dos parametros/colunas no prisma, entao nao precisa colocar
name: name, basta name,

tbm podemos aproveitar e validar se o email ja existe.
no prisma o email e id sao unicos,  pois tao como @unique e @id.
entao podemos usar o findUnique( { email } ) do prisma p fzr
a checagem no banco

Percebemos uma coisa: esse eh core do registro de usuario, ou seja,
qualquer usuario que formos criar, tera aquela validacao,
aquela criptografia, aquela checagem, aquele metodo de criar, etc.

independente se os dados vieram da requisicao, ou se por algum motivo
vier de outro lugar, como por exemplo uma integracao em que o os dados
do usuario para a criacao dele chegue na nossa aplicacao a partir de outro
lugar.

entao essa parte que nao muda, iremos tirar.

_____________________________________________________________


Vamos desacoplar completamente esse core de criacao de usuario.

vamos entao criar uma pasta chamada use-cases, e o arquivo register.ts


Nesse arquivo de caso de uso, vai ficar a criptografia e
as anipulacoes com o prisma. repare que tiramos o "reply" da
checagem de erro, pois ele se refere apenas ao fastify, e
o fastify se refere a requisicao http, mas como ja falamos anteriormente, 
um usuario posteriormente pode ser criado nao por uma requisicao http, mas
por um sistema de messageria, ou uma integracao, etc.

entao essa checagem de email ja em uso, iremos apenas lancar um erro,

Essa funcao que fizemos chamamos de registerUseCase.

No Controller, agora sim, a gente apenas recebe os dados e devolve os dados.
sem precisar mexer com bcrypt ou prisma.

e como la lance um erro, a gente usa um try-catch.

 try {
    await registerUseCase({
        name, 
        email, 
        password
    })
} catch (error) {
    return reply.status(409).send()
}

se o controller chamou o register de caso de uso e deu um erro, nao tem problema,
a gente pega ali no catch.

(questao de mensagens de erro, ainda veremos mais pra frente uma forma melhhor
de lidar com isso.)


RESUMINDO: separamos a funcionalidade logica em si, da parte que eh especficia
da camada hhttp, ou seja, da camada de lidar com requisicao e resposta do nosso
framework (fastify.). Agora, em qualquer lugar da aplicacao podemos chamar o caso 
de uso de criar usuario mandando email, nome e senha. Nao precismaos nos preocupar 
em criar o usuario apenas quando for assim atraves de requisicao http





