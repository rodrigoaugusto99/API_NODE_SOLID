init -y 

src - server.ts

dependencias
typescript,
 @types/node, 
 tsx, (p executar codigo typescript(converte em js pro node poder entender)
 tsup (pra criar o build da aplicacao em js pra quando formos lancamos a aplicacao )
 -d

npx tsc --init   (p criar o arquivo tsconfig.json)
- tsconfig.json es2020

server.ts eh onde vai ficar a instancia do servidor

fastify

server.ts e app.ts
app instanciamos e exppportamos o fastify
no server, importamos essa instancia e 
criamos o server.

host: 0.0.0.0 pra aplicacao ser acessivel por frontends

o listen eh uma promise (future), entao aguardamos o serrvidor subir,
escutando na porta 3333, e ai o then() roda quando ficar pronto


.gitignore

scripts

"scripts": {
    "dev": "tsx watch src/server.ts", - p startar em desenvolvimento, transformando ts em js rapidinho
    "start": "node build src/server.js", - startar pra producao - executar node e executar servidor na 
    pasta js dentro da pasta build
    "build": "tsup src --out-dir build" - pega codigo no src, converte js e joga no /build
  },


  tsx - p rodar o typescript, watch - p ouvir alteracoes, src/server.ts pra rodar aquele arquivo (o servidor no caso)
  tsup src - pegar todo o codigo na pasta src e converter p js, --out-dir - diretacionar o resultado p pasta build

  _____________________________________________________________

.npmrc - save-exact=true

com isso, permite fixar as versões exatas das dependências instaladas em um projeto. 
Isso garante a estabilidade e consistência do ambiente de desenvolvimento e produção, 
prevenindo problemas de compatibilidade e incompatibilidade entre as versões das dependências. 
Além disso, esta configuração ajuda a evitar problemas de segurança, pois impede a 
instalação de versões vulneráveis das dependências.


_____________________________________________________________


vasriaveis ambiente:

variaveis que teremos informacoes diferentes, valores diferentes dado o ambiente da nossa aplciacao,
se estiver executando em testes, producao, desenvovimento, stagiing, essas variaveis podem ter valores
diferentes.

.env com essas variaveis
.env.example p qnd aguem baixar o projeto, ela saber qquais variaveis ela precisa setar,
ate pq o .env vai pro .gitignore

-pra carregar essas variaveis ambiente dentro do projeto - 

npm i dotenv - faz o parse, carrega o arquivo .env e transforma em variaveis ambiente
dentro do node que conseguimsoa cessar via process.env.NODE_ENV

-pra fazer o carregamento de umm jeito mais charmoso, nao tao bruto, tentando acessar
diretamente o process.env:

src/env/index.ts

nesse arquivo, inves de apenas carregar as variaveis ambiente com import dotenv/config, 
tbm vms validar as variaveis ambiente, pois tem variaveis de ambiente na nossa aplicacao que sao
obrigatorias estarem existindo no momento que executamos/iniciamos a nossa apliciacao, por exemplo,
pra aplicacao ser inicializada, tem que ter uma url de banco de dados setada

npm i zod

schema p validar, os 3 ambientes sao:
 dev, test e production, um enum, botamos ate um valor default
 port tbm, z.coerce.number(), caso o valor da porta veio com string, 
 nao tem problema, o coerce transfortma em number. tbm podmos botar default.

 validando - schema.safeParse(process.env)
-isso ve se o process.env corresponde ao schema que fizemos anteriormente.

pra ver se validou ou nao, podemos pegar o resultado desse safeParse.
se for false o _env.success, entao pegamos o _env.error e printamos de forma formatadinha

e lancamos um thhrow error pra parar a aplicacao toda.

se a _env.success foi true, entao exportamos essa variavel privada
export const env = _env
agora podemos usar em qlqr lugar da aplicacao o env.PORT ou env.NODE_ENV

_____________________________________________________________

eslint da rocketseat

npm i eslint @rocketseat/eslint-config -D

criamos a pasta .eslintrc.json p ccolcoar o extends de node.

queremos que esse eslint ignore algumas pastas como build e node_modules.
entao criar 
.eslintignore


_____________________________________________________________
no tsconfig.json:

"baseUrl": "./", 
"paths": {
  "@/*": ["./src/*"]
},  

se tivermos la no escafundoh do judas, se quisermos pegar algo la de fora,
inves de fazer../../../../, podemos tacar um @ logo.


_____________________________________________________________

Fundamentos do Prisma ORM

2a camada - query builders, tipo knex

knex converte pra sql, executa aquela query no nosso banco de dados mas nao tem controle do tipo, 
saber se realmente aquela tabela existe no banco de dados, nois temos que fazer  atipagem dele na mao.
e ai teria que informar tanto a nivel de banco de dados quanto na nossa aplicacao essas coisas do tipo,
os tipos, opcional ou nao, etc.

3o nivel de abstracao - maior - ORMs

prisma, typeorm, sequelize.

prisma ehh o melhor pq diminui muito o trabalho que a gente tem principalmente na parte de duplicidade.
integracao mt boa com typescript. Se temos uma tabela users e tem 10 campos, o prisma compreende a existencia da tabela
e deduz de forma automatizada, a tabela, os campos, e no mesmo momentos que estamos digitando, o prisma consegue te avisar
se tem algo errado ou nao. Migrations tbm sao automatizados. Nao precisamos escrever as migrations tipo: arquivo especifico
pra adicionar coluna na tabela. Apenas precisamos alterar o arquiovo que repreesenta a estrutura no banco de dados
e o prisma automaticamente faz a migration.


npm i prisma -D

instalar em desenvolvimento pois, apesar de usarmos o banco de dados em producao, esse prisma que estamos instalando ainda nao eh 
nao eh o carinhha que faz o acesso ao banco, ehh apenas uma interface de lina de comando

npx prisma init

isso inicializa a parte de conexao com banco de daods na nossa aplicacao

o arquivo schema.prisma vai ser uma represenatacao das tabelas que vamos ter no banco de dados.

mongo chama de colection, sql chama de table, entao no prismo a gente chama de MODEL

nosso primeiro model no schema.prisma:

model User {
  id    String @id @default(uuid())
  name  String
  email String @unique

  @@map("users")
}

 na maioria das vezes, usar uuid ali no id eh pra caso das rotas por exemplo user/2 - onde o id eh exposto.
 ai pra evitar que o usuario coloque um outro id referente a outro usuario, entao ele teria que adivinhar um 
 uuid, o que eh mais dificil.

 Se o id nao for exposto assim no frontend, entao pode ser incremental mesmo


esse @@map("users)
eh so pra renomear a tabela la no banco pra seguirmos o
padrao de letra minusucla e plural.
o @ unico ja se refere a tal coluna
o @@ juntos se referem a tabela como um todo.

npx prisma generate

eai, podemos ver la no node_modules, no prisma, o arquivo index.d.ts,
la aparece a tipagem desse User, (export type), tbm aparece varios
metodos feitos automaticamente como findByUnique, que no caso podemos
usar com o id e o email, etc.

-agora pra trabalhar de fato com o prisma, temos que instalar o 

npm i @prisma/client

esse sim eh dependencia de producao, pois ehh ele que vms usar pra ACESSAR o banco de dados.

dessa forma, veja o seguinte exemplo:


dps de instanciarmos o PrismaClient() como "prisma",

prisma.user.create({
  data: {
    name: 'Rodrigo',
    email: 'rodrigo@prisma.com',
  },
})

tudo tipado certinho, nao podemos colocar number no lugar de string, tudo tem sugestao de acordo com
a tipagem....prisma eh lgl dms

_____________________________________________________________

postgres com docker

meu coker ta no WSL.

docker run --name api_node_solid_pg bitnami/postgresql
esse ehh o comando, mas vms fzr umas configuracoezinhahs antes de rodar o comando

docker run --name api_node_solid_pg -e POSTGRESQL_USERNAME=docker -e POSTGRESQL_PASSWORD=docker 
-e POSTGRESQL_DATABASE=apisolid -p 5432:5432 bitnami/postgresql

aquele -p eh pra posta 5432 do docker poder ser acessada na porta 5432 da nossa maquina localhost.

pronto !

se dermos um stop (crtl c), o docker manteve esse container em cache, entao conseguimos subir ela de novo

se rodar docker ps, aparece todos os container atuais rodando
se rodar docker ps -a, mostra todos os container que ja criamos em algum momento.

se quisermos startar aquele nosso container, so colocar:
  - docker start api_node_solid_pg
que foi o nome que
a gente deu na criacao do container inicialmente.

e pra desligar o container:
  - docker stop api_node_solid_pg


no .env, o prisma ja colocou automaticamente isso:

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

alteramos para

DATABASE_URL="postgresql://docker:docker@localhost:5432/apisolid?schema=public"


---testando que o container e o postgres esta funcionando.:

npx prisma migrate dev - esse comando roda a migration.
Como eh a primeira vez que rodamos e apenas criamos a 
tabela User(users), entao o terminal vai perguntar o nome
dessa migratione  a gente coloca simplesmente create users.

a mensagem que aparece:

migrations/
  └─ 20240518220953_create_users/
    └─ migration.sql

Your database is now in sync with your schema.

beekeeper? posticon? NADA DISSO ! o prisma tem o prisma studio

reda@DESKTOP-2NS8NO9:/mnt/c/documentos/projetos/web/rocketseat/formacao_node/api-solid-03$ npx prisma studio
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Prisma Studio is up on http://localhost:5555

ao rodar:
-  npx prisma studio
conseguimos ter acesso ao banco, as tabelas, de forma facil em uma interface


_____________________________________________________________


docker compose dita quais sao todos os container que precisamos criar p funcionar

docker compose - bota aquelas informacoes que usammos no inicio da criacao do container,
e quem usar a nossa aplicacao eh so rodar:\

 docker compose up -d

(-d em modo background, sem 
mostrar os logs por exemplo.)

pra DELETAR o container e os bancos de dados:

 docker compose down

 pra apenas stoppar o container:

 docker compose stop


se deletar tudo ou algo do tipo, lembrar de roda as migrations de novo.


_____________________________________________________________

criando schema com 

vms criar as tabelas de acordo com os requisitos funcionais.
percebe-se nos req. funcionais que ha entidades que aparecem comumente, 
como academias, usuarios, check-ins, que sao entitades que com certeza
teremos que persistir em alguma estrutura de dados, provavelmente 
banco de dados

models p checkin e gym.

gym vai ter latitude e longidutde obrigatorio por motivos de seguranca,
por ex pra evitar chheckin por outra pessoa, ou checkar muito longe, ou usar 2
celulares, esses tipos de coisas

o validated_at no checkin ta mais interessante do que um booleano is_validated,
porque eh como se fosse um atributo q fala duas coisas, se existir, alem de falar
que tem chheckin, ainda fala a data exata.

ao fzr essas mudancas no schema.prisma, so dar o migrate dev.

_____________________________________________________________


RELACIONAMENTOS.

ainda nao fizemos as chaves estrangeiras.

repare que na tabela de check-ins precismaos colocar 
as chaves erstrangeiras referentes a user e gym, pois
um checkin foi feito por um usuario e um checkin foi 
feito em uma academia.

no caso, seria entao user_id String e gym_id String.
mas dessa forma o prisma nao vai saber que existe tal
relacionamento. 

vamos colocar entao user User na tabela de checkin.
ao darmos ENTER, ja que estamos com a extensao do prisma, e
ja que estamso com aquele onSave true no json config,
entao automaticamente sera criado a linha:

user    User   @relation(fields: [user_id], references: [id])

que diz que o campo user_id se refere ao id do User. 

usamos user_id e gym_id por padrao.
e no caso do checkIns, usamso common case como padrao.
pois vamos usar isso no codigo javascript.

-no prisma studio podemos manipular essas foreign keys tbm, 
podemos setar um usuario praquele checkin, ou um gym praquele checkin,
etc.

_____________________________________________________________

primeiramente, pra testar, foi feito um insert basico. 

no app.ts, um app.post simples

que faz:
validacao do body 
criacao do usuario no banco com os dados.

o que foi feito tambem - tiramos a instancia do prisma e
fizemos em outro arquivo /lib/prisma.ts

nesse arquivo, alem de fazer a instanciacao do PrismaClient
e exportar ele pra aplicacao inteira, tbm ativamos o "log",
para, caso estejamos em ambiente de dev, os logs mostrem
as querys que o prisma faz automaticcamente quando mandamos.

por exemplo, no nosso prisma.user.create({}), aconteceu um log,
'INSERT INTO .....'
no futuro tbm faremos essa condicional no caso de, se for ambiente
de producao, entao vms usar logs apenas para erros.

_____________________________________________________________

Iremos organziar melhor nosso codigo, mas tenha em mente que nao eh
criar mais pastas que vai deixar nosso codigo mais escalavel e manuntenviel.
Mas esse eh o proposito.

Controller eh  um nome dado pra essa funcao que fizemos agora.
Uma funcao que lida com entrrada e saida de dados


a funcao dentro da rota, vira uma funcao exportada na pasta controllers.
a rota que estava em app.ts, jogamos em outra arquivo, que eh uma
funcao exportada contendo todas as rotas. e no app simpelsmente registramos
essa rotas com app.register

ou seja, no app.ts registramos as rotas.
nas rotas, tem cada rota com o controller sendo chamado
nos controllers, tem as regras de negocio.

jaja vms desestrutruar tambem esse controller.

reparemos que a parte de entrada de dados(pegar o body e fazer o parse)
e a parte de retornar dados, eles pertencem ao controller, eeh uma camada.

Entre eles, ha a criacao do usuario, que eh algo independente do resto. nao importa daonde veio os dados,
oq imoporta eh que temos que checar se ha um email igual, temos que criptografar a senha, etc.
Entao vms tirar isso e colocar fora do controller (services, casos de uso, etc)

_____________________________________________________________

npm i bcryptjs - para criptografar senha
npm i -D @types/bcryptjs - para tipar, pois a lib eh em js

import { hash } from 'bcryptjs'

criamos o password_hash com base no password,
hash(passowrd, 6)

com isso, o resultado eh criptografado, 6 rounds
significa 6 rodadas de criptografia, mt bom.

eai, passamos esse resultado pro parametro da senha 
no metodo de criar usuario no prisma.
repare que como o name, email e password_hash sao o nome
dos parametros/colunas no prisma, entao nao precisa colocar
name: name, basta name,

tbm podemos aproveitar e validar se o email ja existe.
no prisma o email e id sao unicos,  pois tao como @unique e @id.
entao podemos usar o findUnique( { email } ) do prisma p fzr
a checagem no banco

Percebemos uma coisa: esse eh core do registro de usuario, ou seja,
qualquer usuario que formos criar, tera aquela validacao,
aquela criptografia, aquela checagem, aquele metodo de criar, etc.

independente se os dados vieram da requisicao, ou se por algum motivo
vier de outro lugar, como por exemplo uma integracao em que o os dados
do usuario para a criacao dele chegue na nossa aplicacao a partir de outro
lugar.

entao essa parte que nao muda, iremos tirar.

_____________________________________________________________


Vamos desacoplar completamente esse core de criacao de usuario.

vamos entao criar uma pasta chamada use-cases, e o arquivo register.ts


Nesse arquivo de caso de uso, vai ficar a criptografia e
as anipulacoes com o prisma. repare que tiramos o "reply" da
checagem de erro, pois ele se refere apenas ao fastify, e
o fastify se refere a requisicao http, mas como ja falamos anteriormente, 
um usuario posteriormente pode ser criado nao por uma requisicao http, mas
por um sistema de messageria, ou uma integracao, etc.

entao essa checagem de email ja em uso, iremos apenas lancar um erro,

Essa funcao que fizemos chamamos de registerUseCase.

No Controller, agora sim, a gente apenas recebe os dados e devolve os dados.
sem precisar mexer com bcrypt ou prisma.

e como la lance um erro, a gente usa um try-catch.

 try {
    await registerUseCase({
        name, 
        email, 
        password
    })
} catch (error) {
    return reply.status(409).send()
}

se o controller chamou o register de caso de uso e deu um erro, nao tem problema,
a gente pega ali no catch.

(questao de mensagens de erro, ainda veremos mais pra frente uma forma melhhor
de lidar com isso.)


RESUMINDO: separamos a funcionalidade logica em si, da parte que eh especficia
da camada hhttp, ou seja, da camada de lidar com requisicao e resposta do nosso
framework (fastify.). Agora, em qualquer lugar da aplicacao podemos chamar o caso 
de uso de criar usuario mandando email, nome e senha. Nao precismaos nos preocupar 
em criar o usuario apenas quando for assim atraves de requisicao http


_______________________________


Repositoy Pattern

vamos tirar o codigo espeecifico de uma ferramenta(prisma) e colocar na pasta repositories. 
Apenas la vamos usar a logica do prisma e se comunicar com o banco de dados, pois vamos supor
que eu queira trocar o prisma por sequelize. Entao vms mexer apenas nessa pasta repositories. 

basicamente estamos protegendo nossa aplicacao de dependencias externas.

usamos a tipagem que o prisma gerou que serve para criiar um usuario, para poder
colocar como parametro, assim, nao precisamos denovo fazer a tipagem/interface pra
criar usuario (poderiamos separar em um arquivo essa interface tbm por exemplo.)


_____________________________

Inversao de Dependencia.

apesar do prisma estar totalmente desacoplado, o use-case de register continua dependente daquele repositorio.

oq vamos fazer eh, ao inves de instanciarmos o repositorio dentro do use-case, vamos receber ele por parametro.

isso vai ser bom pois, se quisermos trocar prisma pra sequelize, entao vamos ter que trocar a nomeclatura tbm
da instanciacao de todos os lugares que importamos esse repositorio.

Pra isso, nois entao nao vamos enviar ali no parametro diretamente, misturado com os outros parametros. 
Vamos envolver essa funcao em uma classe para podermos usar o construtor da classe. e sim, a classe tera
apenas um metodo.

a classe vai ter o mesmo nome da funcao, mas com o nome maiusculo. Entao, o nome da funcao vai ser algo mais generico, 
como handle ou execute.

no construtor vamos receber o repositorio. vamos chamar ele obviamente com um nome generico, pois pode vir 
prismaRepository, sequelizeRepository, qualquer coisa.

agora, a RESPONSABILIDADE de escolher o repositorio nao sera mais do use-case, mas sim, de que CHAMA-LO, que no caso,
eh o controller. La no controller, vamos instanciar o repositorio E instanciar a classe RegisterUseCase passando
aquele repositorio instanciado como parametro.
eai, eh so chamar essa classe + o metodo com os parametros normais. a classe ja ta com a dependencia injetada.


Resumindo: a inversao de dependencia fez com que: o arquivo que precisar do caso de uso, do register use case,
eh ele que vai enviar as dependencias como parametro. Agora o use-case nao vai ter nadica de nada relacionado ao prisma.
pois apesar do prisma ter sido desacoplado e colocado no repositorio, o use-case tbm tinha que instancia-lo, tinha
que se preocupar em pegar o repositorio correspondente, no caso, aquele do prisma.

__________________________

Precisamos de uma interface para se referir a qualquer repositorio.
Dessa forma, no construtor re RegisterUseCase, vai ficar usersRepository: UserRepository, ai inves de any
ou de PrismaRepository(que tbm estaria errado pois o use-case ficaria sabendo do prisma, ficaria dependente, 
e queremos nao ter nenhuma mencao do prisma, queremos apenas que esse use-case chame o repositorio, sem
precisar saber qual a implementacao concreta dele.)

Pra isso vamos usar uma interface (pode ser classe abstrata tbm.)

Com essa classe abstrata, todos os use-cases que chamarem repositorio vao esperar como parametro essa interface,
que corresponde a qualquer repositorio. Nessa interface, vamos colocar APENAS a assinatura do metodo, nao vamos 
implementa-lo. Dessa forma,  a interface determina que toda classe (repositorio no caso) que implementar ela, vai
precisar daquele metodo com aquele nome e com aquele tipo de parametro.

Com a interface criada, ele vai ser a tipagem do repositorio que cada use-case que chamar o repositorio vai esperar por parametro.

Dessa forma, o repositorio de users (prisma, sequelize, etc), tera que implementar (implements) essa interface

Podemos tbm criar uma pasta dentro da pasta repositorioes chamada prisma, e la colocamos todas as implementacoes
de repositorios que utilizam o prisma.

Eh a interface que eh o contrato, ela que vai decidir quais metodos vao existir na comunicacao
do repositorio com o caso de uso, quais os parametros e etc.



____________________________

A gente retorna erros no use-case, podemos retornar varios tipos de erros.

No controller, chamamos o use-case com um try-catch caso tenha erro. Mas no catch
retornamos apenas um reply.status com status do erro.

Mas pode ser varios erros, entao vamos criar uma pasta errors dentro da pasta use-cases e fazer classes pra todos os tipos de erros.
essa classe extende a classe Error nativa do js, chama o super(), que eh o construtor do Error, que eh o que estavamos
chamando anteriormente com throw new Error('xxx'), e colocamos a mensagem especifica ali.
Dessa forma, quando formos dar um throw error, vamos dar o throw na classe de erro correspondente.

la no controller, podemos fzr as condicionais p ver os erros e retornar o status correto, alem de recuperar a mensagem tbm.


_____________

La no app.ts, podemos fazer um handler global de erros, pra erros que a gente nao tratou ou pra erros que nao conhecemos.
la, colocamos condicional p erro de ZodError, e tbm fazemos log no erro pra caso estejamos rodando em ambiente de dev ou test.
Se for ambiente de producao, o log vai ser numa ferramenta externa de observabilidade.

e por fim, um erro generico 500, obviamente.


Dessa forma, caso aconteca um erro la no controller que nao capturamos nas condiconais  do catch, entao la mesmo depois das 
condicionais a gente faz um throw error, um throw no proprio error que veio no catch(error), dessa forma, deixamos pro
setErrorHandler do fastify pra lidar globalmente com esses erros, eh como se fosse uma pia. A gente joga os restos de comida
do prato fora, mas caso sobrar algo, mesmo assim nao vai descer no cano, pois tem uma rede ali no ralo pra pegar os restinhos
de comida por precaucao.