init -y 

src - server.ts

typescript, types/node, tsx, tsup -d

npx tsc --init   - tsconfig.json es2020

fastify

server.ts e app.ts

.gitignore

scripts

"scripts": {
    "dev": "tsx watch src/server.ts", - p startar em desenvolvimento, transformando ts em js rapidinho
    "start": "node build src/server.js", - startar pra producao - executar node e executar servidor na 
    pasta js dentro da pasta build
    "build": "tsup src --out-dir build" - pega codigo no src, converte js e joga no /build
  },

  _____________________________________________________________

.npmrc - save-exact=true

com isso, permite fixar as versões exatas das dependências instaladas em um projeto. 
Isso garante a estabilidade e consistência do ambiente de desenvolvimento e produção, 
prevenindo problemas de compatibilidade e incompatibilidade entre as versões das dependências. 
Além disso, esta configuração ajuda a evitar problemas de segurança, pois impede a 
instalação de versões vulneráveis das dependências.


_____________________________________________________________


vasriaveis ambiente:

variaveis que teremos informacoes diferentes, valores diferentes dado o ambiente da nossa aplciacao,
se estiver executando em testes, producao, desenvovimento, stagiing, essas variaveis podem ter valores
diferentes.

.env com essas variaveis
.env.example p qnd aguem baixar o projeto, ela saber qquais variaveis ela precisa setar,
ate pq o .env vai pro .gitignore

-pra carregar essas variaveis ambiente dentro do projeto - 

npm i dotenv - faz o parse, carrega o arquivo .env e transforma em variaveis ambiente
dentro do node que conseguimsoa cessar via process.env.NODE_ENV

-pra fazer o carregamento de umm jeito mais charmoso, nao tao bruto, tentando acessar
diretamente o process.env:

src/env/index.ts

nesse arquivo, inves de apenas carregar as variaveis ambiente com import dotenv/config, 
tbm vms validar as variaveis ambiente, pois tem variaveis de ambiente na nossa aplicacao que sao
obrigatorias estarem existindo no momento que executamos/iniciamos a nossa apliciacao, por exemplo,
pra aplicacao ser inicializada, tem que ter uma url de banco de dados setada

npm i zod

schema p validar, os 3 ambientes sao:
 dev, test e production, um enum, botamos ate um valor default
 port tbm, z.coerce.number(), caso o valor da porta veio com string, 
 nao tem problema, o coerce transfortma em number. tbm podmos botar default.

 validando - schema.safeParse(process.env)
-isso ve se o process.env corresponde ao schema que fizemos anteriormente.

pra ver se validou ou nao, podemos pegar o resultado desse safeParse.
se for false o _env.success, entao pegamos o _env.error e printamos de forma formatadinha

e lancamos um thhrow error pra parar a aplicacao toda.

se a _env.success foi true, entao exportamos essa variavel privada
export const env = _env
agora podemos usar em qlqr lugar da aplicacao o env.PORT ou env.NODE_ENV

_____________________________________________________________

eslint da rocketseat

npm i eslint @rocketseat/eslint-config -D

criamos a pasta .eslintrc.json p ccolcoar o extends de node.

queremos que esse eslint ignore algumas pastas como build e node_modules.
entao criar 
.eslintignore


_____________________________________________________________
no tsconfig.json:

"baseUrl": "./", 
"paths": {
  "@/*": ["./src/*"]
},  

se tivermos la no escafundoh do judas, se quisermos pegar algo la de fora,
inves de fazer../../../../, podemos tacar um @ logo.


_____________________________________________________________

Fundamentos do Prisma ORM

2a camada - query builders, tipo knex

knex converte pra sql, executa aquela query no nosso banco de dados mas nao tem controle do tipo, 
saber se realmente aquela tabela existe no banco de dados, nois temos que fazer  atipagem dele na mao.
e ai teria que informar tanto a nivel de banco de dados quanto na nossa aplicacao essas coisas do tipo,
os tipos, opcional ou nao, etc.

3o nivel de abstracao - maior - ORMs

prisma, typeorm, sequelize.

prisma ehh o melhor pq diminui muito o trabalho que a gente tem principalmente na parte de duplicidade.
integracao mt boa com typescript. Se temos uma tabela users e tem 10 campos, o prisma compreende a existencia da tabela
e deduz de forma automatizada, a tabela, os campos, e no mesmo momentos que estamos digitando, o prisma consegue te avisar
se tem algo errado ou nao. Migrations tbm sao automatizados. Nao precisamos escrever as migrations tipo: arquivo especifico
pra adicionar coluna na tabela. Apenas precisamos alterar o arquiovo que repreesenta a estrutura no banco de dados
e o prisma automaticamente faz a migration.


npm i prisma -D

instalar em desenvolvimento pois, apesar de usarmos o banco de dados em producao, esse prisma que estamos instalando ainda nao eh 
nao eh o carinhha que faz o acesso ao banco, ehh apenas uma interface de lina de comando

npx prisma init

isso inicializa a parte de conexao com banco de daods na nossa aplicacao

o arquivo schema.prisma vai ser uma represenatacao das tabelas que vamos ter no banco de dados.

mongo chama de colection, sql chama de table, entao no prismo a gente chama de MODEL

nosso primeiro model no schema.prisma:

model User {
  id    String @id @default(uuid())
  name  String
  email String @unique

  @@map("users")
}

npx prisma generate

eai, podemos ver la no node_modules, no prisma, o arquivo index.d.ts,
la aparece a tipagem desse User, (export type), tbm aparece varios
metodos feitos automaticamente como findByUnique, que no caso podemos
usar com o id e o email, etc.

-agora pra trabalhar de fato com o prisma, temos que instalar o 

npm i @prisma/client

esse sim eh dependencia de producao, pois ehh ele que vms usar pra ACESSAR o banco de dados.

dessa forma, veja o seguinte exemplo:


dps de instanciarmos o PrismaClient() como "prisma",

prisma.user.create({
  data: {
    name: 'Rodrigo',
    email: 'rodrigo@prisma.com',
  },
})

tudo tipado certinho, nao podemos colocar number no lugar de string, tudo tem sugestao de acordo com
a tipagem....prisma eh lgl dms

_____________________________________________________________

postgres com docker

meu coker ta no WSL.

docker run --name api_node_solid_pg bitnami/postgresql
esse ehh o comando, mas vms fzr umas configuracoezinhahs antes de rodar o comando

docker run --name api_node_solid_pg -e POSTGRESQL_USERNAME=docker -e POSTGRESQL_PASSWORD=docker 
-e POSTGRESQL_DATABASE=apisolid -p 5432:5432 bitnami/postgresql

pronto !

se dermos um stop (crtl c), o docker manteve esse container em cache, entao conseguimos subir ela de novo

se rodar docker ps, aparece todos os container atuais rodando
se rodar docker ps -a, mostra todos os container que ja criamos em algum momento.

se quisermos startar aquele nosso container, so colocar:
  - docker start api_node_solid_pg
que foi o nome que
a gente deu na criacao do container inicialmente.

e pra desligar o container:
  - docker stop api_node_solid_pg


no .env, o prisma ja colocou automaticamente isso:

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

alteramos para

DATABASE_URL="postgresql://docker:docker@localhost:5432/apisolid?schema=public"


---testando que o container e o postgres esta funcionando.:

npx prisma migrate dev - esse comando roda a migration.
Como eh a primeira vez que rodamos e apenas criamos a 
tabela User(users), entao o terminal vai perguntar o nome
dessa migratione  a gente coloca simplesmente create users.

a mensagem que aparece:

migrations/
  └─ 20240518220953_create_users/
    └─ migration.sql

Your database is now in sync with your schema.

beekeeper? posticon? NADA DISSO ! o prisma tem o prisma studio

reda@DESKTOP-2NS8NO9:/mnt/c/documentos/projetos/web/rocketseat/formacao_node/api-solid-03$ npx prisma studio
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Prisma Studio is up on http://localhost:5555

ao rodar:
-  npx prisma studio
conseguimos ter acesso ao banco, as tabelas, de forma facil em uma interface


_____________________________________________________________




docker compose - bota aquelas informacoes que usammos no inicio da criacao do container,
e quem usar a nossa aplicacao eh so rodar:\

 docker compose up -d

(-d em modo background, sem 
mostrar os logs por exemplo.)

pra DELETAR o container e os bancos de dados:

 docker compose down

 pra apenas stoppar o container:

 docker compose stop


se deletar tudo ou algo do tipo, lembrar de roda as migrations de novo.


_____________________________________________________________

criando schema com 

vms criar as tabelas de acordo com os requisitos funcionais.
percebe-se nos req. funcionais que ha entidades que aparecem comumente, 
como academias, usuarios, check-ins, que sao entitades que com certeza
teremos que persistir em alguma estrutura de dados, provavelmente 
banco de dados

models p checkin e gym.

gym vai ter latitude e longidutde obrigatorio por motivos de seguranca,
por ex pra evitar chheckin por outra pessoa, ou checkar muito longe, ou usar 2
celulares, esses tipos de coisas

o validated_at no checkin ta mais interessante do que um booleano is_validated,
porque eh como se fosse um atributo q fala duas coisas, se existir, alem de falar
que tem chheckin, ainda fala a data exata.

ao fzr essas mudancas no schema.prisma, so dar o migrate dev.
















