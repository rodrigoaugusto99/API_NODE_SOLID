init -y 

src - server.ts

typescript, types/node, tsx, tsup -d

npx tsc --init   - tsconfig.json es2020

fastify

server.ts e app.ts

.gitignore

scripts

"scripts": {
    "dev": "tsx watch src/server.ts", - p startar em desenvolvimento, transformando ts em js rapidinho
    "start": "node build src/server.js", - startar pra producao - executar node e executar servidor na 
    pasta js dentro da pasta build
    "build": "tsup src --out-dir build" - pega codigo no src, converte js e joga no /build
  },

  _____________________________________________________________

.npmrc - save-exact=true

com isso, permite fixar as versões exatas das dependências instaladas em um projeto. 
Isso garante a estabilidade e consistência do ambiente de desenvolvimento e produção, 
prevenindo problemas de compatibilidade e incompatibilidade entre as versões das dependências. 
Além disso, esta configuração ajuda a evitar problemas de segurança, pois impede a 
instalação de versões vulneráveis das dependências.


_____________________________________________________________


vasriaveis ambiente:

variaveis que teremos informacoes diferentes, valores diferentes dado o ambiente da nossa aplciacao,
se estiver executando em testes, producao, desenvovimento, stagiing, essas variaveis podem ter valores
diferentes.

.env com essas variaveis
.env.example p qnd aguem baixar o projeto, ela saber qquais variaveis ela precisa setar,
ate pq o .env vai pro .gitignore

-pra carregar essas variaveis ambiente dentro do projeto - 

npm i dotenv - faz o parse, carrega o arquivo .env e transforma em variaveis ambiente
dentro do node que conseguimsoa cessar via process.env.NODE_ENV

-pra fazer o carregamento de umm jeito mais charmoso, nao tao bruto, tentando acessar
diretamente o process.env:

src/env/index.ts

nesse arquivo, inves de apenas carregar as variaveis ambiente com import dotenv/config, 
tbm vms validar as variaveis ambiente, pois tem variaveis de ambiente na nossa aplicacao que sao
obrigatorias estarem existindo no momento que executamos/iniciamos a nossa apliciacao, por exemplo,
pra aplicacao ser inicializada, tem que ter uma url de banco de dados setada

npm i zod

schema p validar, os 3 ambientes sao:
 dev, test e production, um enum, botamos ate um valor default
 port tbm, z.coerce.number(), caso o valor da porta veio com string, 
 nao tem problema, o coerce transfortma em number. tbm podmos botar default.

 validando - schema.safeParse(process.env)
-isso ve se o process.env corresponde ao schema que fizemos anteriormente.

pra ver se validou ou nao, podemos pegar o resultado desse safeParse.
se for false o _env.success, entao pegamos o _env.error e printamos de forma formatadinha

e lancamos um thhrow error pra parar a aplicacao toda.

se a _env.success foi true, entao exportamos essa variavel privada
export const env = _env
agora podemos usar em qlqr lugar da aplicacao o env.PORT ou env.NODE_ENV

_____________________________________________________________

eslint da rocketseat

npm i eslint @rocketseat/eslint-config -D

criamos a pasta .eslintrc.json p ccolcoar o extends de node.

queremos que esse eslint ignore algumas pastas como build e node_modules.
entao criar 
.eslintignore


_____________________________________________________________
no tsconfig.json:

"baseUrl": "./", 
"paths": {
  "@/*": ["./src/*"]
},  

se tivermos la no escafundoh do judas, se quisermos pegar algo la de fora,
inves de fazer../../../../, podemos tacar um @ logo.


_____________________________________________________________

Fundamentos do Prisma ORM

2a camada - query builders, tipo knex

knex converte pra sql, executa aquela query no nosso banco de dados mas nao tem controle do tipo, 
saber se realmente aquela tabela existe no banco de dados, nois temos que fazer  atipagem dele na mao.
e ai teria que informar tanto a nivel de banco de dados quanto na nossa aplicacao essas coisas do tipo,
os tipos, opcional ou nao, etc.

3o nivel de abstracao - maior - ORMs

prisma, typeorm, sequelize.

prisma ehh o melhor pq diminui muito o trabalho que a gente tem principalmente na parte de duplicidade.
integracao mt boa com typescript. Se temos uma tabela users e tem 10 campos, o prisma compreende a existencia da tabela
e deduz de forma automatizada, a tabela, os campos, e no mesmo momentos que estamos digitando, o prisma consegue te avisar
se tem algo errado ou nao. Migrations tbm sao automatizados. Nao precisamos escrever as migrations tipo: arquivo especifico
pra adicionar coluna na tabela. Apenas precisamos alterar o arquiovo que repreesenta a estrutura no banco de dados
e o prisma automaticamente faz a migration.


npm i prisma -D

instalar em desenvolvimento pois, apesar de usarmos o banco de dados em producao, esse prisma que estamos instalando ainda nao eh 
nao eh o carinhha que faz o acesso ao banco, ehh apenas uma interface de lina de comando

npx prisma init

isso inicializa a parte de conexao com banco de daods na nossa aplicacao

o arquivo schema.prisma vai ser uma represenatacao das tabelas que vamos ter no banco de dados.

mongo chama de colection, sql chama de table, entao no prismo a gente chama de MODEL

nosso primeiro model no schema.prisma:

model User {
  id    String @id @default(uuid())
  name  String
  email String @unique

  @@map("users")
}

npx prisma generate

eai, podemos ver la no node_modules, no prisma, o arquivo index.d.ts,
la aparece a tipagem desse User, (export type), tbm aparece varios
metodos feitos automaticamente como findByUnique, que no caso podemos
usar com o id e o email, etc.

-agora pra trabalhar de fato com o prisma, temos que instalar o 

npm i @prisma/client

esse sim eh dependencia de producao, pois ehh ele que vms usar pra ACESSAR o banco de dados.

dessa forma, veja o seguinte exemplo:


dps de instanciarmos o PrismaClient() como "prisma",

prisma.user.create({
  data: {
    name: 'Rodrigo',
    email: 'rodrigo@prisma.com',
  },
})

tudo tipado certinho, nao podemos colocar number no lugar de string, tudo tem sugestao de acordo com
a tipagem....prisma eh lgl dms





