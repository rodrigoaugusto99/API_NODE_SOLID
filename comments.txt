init -y 

src - server.ts

dependencias
typescript,
 @types/node, 
 tsx, (p executar codigo typescript(converte em js pro node poder entender)
 tsup (pra criar o build da aplicacao em js pra quando formos lancamos a aplicacao )
 -d

npx tsc --init   (p criar o arquivo tsconfig.json)
- tsconfig.json es2020

server.ts eh onde vai ficar a instancia do servidor

fastify

server.ts e app.ts
app instanciamos e exppportamos o fastify
no server, importamos essa instancia e 
criamos o server.

host: 0.0.0.0 pra aplicacao ser acessivel por frontends

o listen eh uma promise (future), entao aguardamos o serrvidor subir,
escutando na porta 3333, e ai o then() roda quando ficar pronto


.gitignore

scripts

"scripts": {
    "dev": "tsx watch src/server.ts", - p startar em desenvolvimento, transformando ts em js rapidinho
    "start": "node build src/server.js", - startar pra producao - executar node e executar servidor na 
    pasta js dentro da pasta build
    "build": "tsup src --out-dir build" - pega codigo no src, converte js e joga no /build
  },


  tsx - p rodar o typescript, watch - p ouvir alteracoes, src/server.ts pra rodar aquele arquivo (o servidor no caso)
  tsup src - pegar todo o codigo na pasta src e converter p js, --out-dir - diretacionar o resultado p pasta build

  _____________________________________________________________

.npmrc - save-exact=true

com isso, permite fixar as versões exatas das dependências instaladas em um projeto. 
Isso garante a estabilidade e consistência do ambiente de desenvolvimento e produção, 
prevenindo problemas de compatibilidade e incompatibilidade entre as versões das dependências. 
Além disso, esta configuração ajuda a evitar problemas de segurança, pois impede a 
instalação de versões vulneráveis das dependências.


_____________________________________________________________


vasriaveis ambiente:

variaveis que teremos informacoes diferentes, valores diferentes dado o ambiente da nossa aplciacao,
se estiver executando em testes, producao, desenvovimento, stagiing, essas variaveis podem ter valores
diferentes.

.env com essas variaveis
.env.example p qnd aguem baixar o projeto, ela saber qquais variaveis ela precisa setar,
ate pq o .env vai pro .gitignore

-pra carregar essas variaveis ambiente dentro do projeto - 

npm i dotenv - faz o parse, carrega o arquivo .env e transforma em variaveis ambiente
dentro do node que conseguimsoa cessar via process.env.NODE_ENV

-pra fazer o carregamento de umm jeito mais charmoso, nao tao bruto, tentando acessar
diretamente o process.env:

src/env/index.ts

nesse arquivo, inves de apenas carregar as variaveis ambiente com import dotenv/config, 
tbm vms validar as variaveis ambiente, pois tem variaveis de ambiente na nossa aplicacao que sao
obrigatorias estarem existindo no momento que executamos/iniciamos a nossa apliciacao, por exemplo,
pra aplicacao ser inicializada, tem que ter uma url de banco de dados setada

npm i zod

schema p validar, os 3 ambientes sao:
 dev, test e production, um enum, botamos ate um valor default
 port tbm, z.coerce.number(), caso o valor da porta veio com string, 
 nao tem problema, o coerce transfortma em number. tbm podmos botar default.

 validando - schema.safeParse(process.env)
-isso ve se o process.env corresponde ao schema que fizemos anteriormente.

pra ver se validou ou nao, podemos pegar o resultado desse safeParse.
se for false o _env.success, entao pegamos o _env.error e printamos de forma formatadinha

e lancamos um thhrow error pra parar a aplicacao toda.

se a _env.success foi true, entao exportamos essa variavel privada
export const env = _env
agora podemos usar em qlqr lugar da aplicacao o env.PORT ou env.NODE_ENV

_____________________________________________________________

eslint da rocketseat

npm i eslint @rocketseat/eslint-config -D

criamos a pasta .eslintrc.json p ccolcoar o extends de node.

queremos que esse eslint ignore algumas pastas como build e node_modules.
entao criar 
.eslintignore


_____________________________________________________________
no tsconfig.json:

"baseUrl": "./", 
"paths": {
  "@/*": ["./src/*"]
},  

se tivermos la no escafundoh do judas, se quisermos pegar algo la de fora,
inves de fazer../../../../, podemos tacar um @ logo.


_____________________________________________________________

Fundamentos do Prisma ORM

2a camada - query builders, tipo knex

knex converte pra sql, executa aquela query no nosso banco de dados mas nao tem controle do tipo, 
saber se realmente aquela tabela existe no banco de dados, nois temos que fazer  atipagem dele na mao.
e ai teria que informar tanto a nivel de banco de dados quanto na nossa aplicacao essas coisas do tipo,
os tipos, opcional ou nao, etc.

3o nivel de abstracao - maior - ORMs

prisma, typeorm, sequelize.

prisma ehh o melhor pq diminui muito o trabalho que a gente tem principalmente na parte de duplicidade.
integracao mt boa com typescript. Se temos uma tabela users e tem 10 campos, o prisma compreende a existencia da tabela
e deduz de forma automatizada, a tabela, os campos, e no mesmo momentos que estamos digitando, o prisma consegue te avisar
se tem algo errado ou nao. Migrations tbm sao automatizados. Nao precisamos escrever as migrations tipo: arquivo especifico
pra adicionar coluna na tabela. Apenas precisamos alterar o arquiovo que repreesenta a estrutura no banco de dados
e o prisma automaticamente faz a migration.


npm i prisma -D

instalar em desenvolvimento pois, apesar de usarmos o banco de dados em producao, esse prisma que estamos instalando ainda nao eh 
nao eh o carinhha que faz o acesso ao banco, ehh apenas uma interface de lina de comando

npx prisma init

isso inicializa a parte de conexao com banco de daods na nossa aplicacao

o arquivo schema.prisma vai ser uma represenatacao das tabelas que vamos ter no banco de dados.

mongo chama de colection, sql chama de table, entao no prismo a gente chama de MODEL

nosso primeiro model no schema.prisma:

model User {
  id    String @id @default(uuid())
  name  String
  email String @unique

  @@map("users")
}

 na maioria das vezes, usar uuid ali no id eh pra caso das rotas por exemplo user/2 - onde o id eh exposto.
 ai pra evitar que o usuario coloque um outro id referente a outro usuario, entao ele teria que adivinhar um 
 uuid, o que eh mais dificil.

 Se o id nao for exposto assim no frontend, entao pode ser incremental mesmo


esse @@map("users)
eh so pra renomear a tabela la no banco pra seguirmos o
padrao de letra minusucla e plural.
o @ unico ja se refere a tal coluna
o @@ juntos se referem a tabela como um todo.

npx prisma generate

eai, podemos ver la no node_modules, no prisma, o arquivo index.d.ts,
la aparece a tipagem desse User, (export type), tbm aparece varios
metodos feitos automaticamente como findByUnique, que no caso podemos
usar com o id e o email, etc.

-agora pra trabalhar de fato com o prisma, temos que instalar o 

npm i @prisma/client

esse sim eh dependencia de producao, pois ehh ele que vms usar pra ACESSAR o banco de dados.

dessa forma, veja o seguinte exemplo:


dps de instanciarmos o PrismaClient() como "prisma",

prisma.user.create({
  data: {
    name: 'Rodrigo',
    email: 'rodrigo@prisma.com',
  },
})

tudo tipado certinho, nao podemos colocar number no lugar de string, tudo tem sugestao de acordo com
a tipagem....prisma eh lgl dms

_____________________________________________________________

postgres com docker

meu coker ta no WSL.

docker run --name api_node_solid_pg bitnami/postgresql
esse ehh o comando, mas vms fzr umas configuracoezinhahs antes de rodar o comando

docker run --name api_node_solid_pg -e POSTGRESQL_USERNAME=docker -e POSTGRESQL_PASSWORD=docker 
-e POSTGRESQL_DATABASE=apisolid -p 5432:5432 bitnami/postgresql

aquele -p eh pra posta 5432 do docker poder ser acessada na porta 5432 da nossa maquina localhost.

pronto !

se dermos um stop (crtl c), o docker manteve esse container em cache, entao conseguimos subir ela de novo

se rodar docker ps, aparece todos os container atuais rodando
se rodar docker ps -a, mostra todos os container que ja criamos em algum momento.

se quisermos startar aquele nosso container, so colocar:
  - docker start api_node_solid_pg
que foi o nome que
a gente deu na criacao do container inicialmente.

e pra desligar o container:
  - docker stop api_node_solid_pg


no .env, o prisma ja colocou automaticamente isso:

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

alteramos para

DATABASE_URL="postgresql://docker:docker@localhost:5432/apisolid?schema=public"


---testando que o container e o postgres esta funcionando.:

npx prisma migrate dev - esse comando roda a migration.
Como eh a primeira vez que rodamos e apenas criamos a 
tabela User(users), entao o terminal vai perguntar o nome
dessa migratione  a gente coloca simplesmente create users.

a mensagem que aparece:

migrations/
  └─ 20240518220953_create_users/
    └─ migration.sql

Your database is now in sync with your schema.

beekeeper? posticon? NADA DISSO ! o prisma tem o prisma studio

reda@DESKTOP-2NS8NO9:/mnt/c/documentos/projetos/web/rocketseat/formacao_node/api-solid-03$ npx prisma studio
Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Prisma Studio is up on http://localhost:5555

ao rodar:
-  npx prisma studio
conseguimos ter acesso ao banco, as tabelas, de forma facil em uma interface


_____________________________________________________________


docker compose dita quais sao todos os container que precisamos criar p funcionar

docker compose - bota aquelas informacoes que usammos no inicio da criacao do container,
e quem usar a nossa aplicacao eh so rodar:\

 docker compose up -d

(-d em modo background, sem 
mostrar os logs por exemplo.)

pra DELETAR o container e os bancos de dados:

 docker compose down

 pra apenas stoppar o container:

 docker compose stop


se deletar tudo ou algo do tipo, lembrar de roda as migrations de novo.


_____________________________________________________________

criando schema com 

vms criar as tabelas de acordo com os requisitos funcionais.
percebe-se nos req. funcionais que ha entidades que aparecem comumente, 
como academias, usuarios, check-ins, que sao entitades que com certeza
teremos que persistir em alguma estrutura de dados, provavelmente 
banco de dados

models p checkin e gym.

gym vai ter latitude e longidutde obrigatorio por motivos de seguranca,
por ex pra evitar chheckin por outra pessoa, ou checkar muito longe, ou usar 2
celulares, esses tipos de coisas

o validated_at no checkin ta mais interessante do que um booleano is_validated,
porque eh como se fosse um atributo q fala duas coisas, se existir, alem de falar
que tem chheckin, ainda fala a data exata.

ao fzr essas mudancas no schema.prisma, so dar o migrate dev.

_____________________________________________________________


RELACIONAMENTOS.

ainda nao fizemos as chaves estrangeiras.

repare que na tabela de check-ins precismaos colocar 
as chaves erstrangeiras referentes a user e gym, pois
um checkin foi feito por um usuario e um checkin foi 
feito em uma academia.

no caso, seria entao user_id String e gym_id String.
mas dessa forma o prisma nao vai saber que existe tal
relacionamento. 

vamos colocar entao user User na tabela de checkin.
ao darmos ENTER, ja que estamos com a extensao do prisma, e
ja que estamso com aquele onSave true no json config,
entao automaticamente sera criado a linha:

user    User   @relation(fields: [user_id], references: [id])

que diz que o campo user_id se refere ao id do User. 

usamos user_id e gym_id por padrao.
e no caso do checkIns, usamso common case como padrao.
pois vamos usar isso no codigo javascript.

-no prisma studio podemos manipular essas foreign keys tbm, 
podemos setar um usuario praquele checkin, ou um gym praquele checkin,
etc.

_____________________________________________________________

primeiramente, pra testar, foi feito um insert basico. 

no app.ts, um app.post simples

que faz:
validacao do body 
criacao do usuario no banco com os dados.

o que foi feito tambem - tiramos a instancia do prisma e
fizemos em outro arquivo /lib/prisma.ts

nesse arquivo, alem de fazer a instanciacao do PrismaClient
e exportar ele pra aplicacao inteira, tbm ativamos o "log",
para, caso estejamos em ambiente de dev, os logs mostrem
as querys que o prisma faz automaticcamente quando mandamos.

por exemplo, no nosso prisma.user.create({}), aconteceu um log,
'INSERT INTO .....'
no futuro tbm faremos essa condicional no caso de, se for ambiente
de producao, entao vms usar logs apenas para erros.

_____________________________________________________________

Iremos organziar melhor nosso codigo, mas tenha em mente que nao eh
criar mais pastas que vai deixar nosso codigo mais escalavel e manuntenviel.
Mas esse eh o proposito.

Controller eh  um nome dado pra essa funcao que fizemos agora.
Uma funcao que lida com entrrada e saida de dados


a funcao dentro da rota, vira uma funcao exportada na pasta controllers.
a rota que estava em app.ts, jogamos em outra arquivo, que eh uma
funcao exportada contendo todas as rotas. e no app simpelsmente registramos
essa rotas com app.register

ou seja, no app.ts registramos as rotas.
nas rotas, tem cada rota com o controller sendo chamado
nos controllers, tem as regras de negocio.

jaja vms desestrutruar tambem esse controller.

reparemos que a parte de entrada de dados(pegar o body e fazer o parse)
e a parte de retornar dados, eles pertencem ao controller, eeh uma camada.

Entre eles, ha a criacao do usuario, que eh algo independente do resto. nao importa daonde veio os dados,
oq imoporta eh que temos que checar se ha um email igual, temos que criptografar a senha, etc.
Entao vms tirar isso e colocar fora do controller (services, casos de uso, etc)

_____________________________________________________________

npm i bcryptjs - para criptografar senha
npm i -D @types/bcryptjs - para tipar, pois a lib eh em js

import { hash } from 'bcryptjs'

criamos o password_hash com base no password,
hash(passowrd, 6)

com isso, o resultado eh criptografado, 6 rounds
significa 6 rodadas de criptografia, mt bom.

eai, passamos esse resultado pro parametro da senha 
no metodo de criar usuario no prisma.
repare que como o name, email e password_hash sao o nome
dos parametros/colunas no prisma, entao nao precisa colocar
name: name, basta name,

tbm podemos aproveitar e validar se o email ja existe.
no prisma o email e id sao unicos,  pois tao como @unique e @id.
entao podemos usar o findUnique( { email } ) do prisma p fzr
a checagem no banco

Percebemos uma coisa: esse eh core do registro de usuario, ou seja,
qualquer usuario que formos criar, tera aquela validacao,
aquela criptografia, aquela checagem, aquele metodo de criar, etc.

independente se os dados vieram da requisicao, ou se por algum motivo
vier de outro lugar, como por exemplo uma integracao em que o os dados
do usuario para a criacao dele chegue na nossa aplicacao a partir de outro
lugar.

entao essa parte que nao muda, iremos tirar.

_____________________________________________________________


Vamos desacoplar completamente esse core de criacao de usuario.

vamos entao criar uma pasta chamada use-cases, e o arquivo register.ts


Nesse arquivo de caso de uso, vai ficar a criptografia e
as anipulacoes com o prisma. repare que tiramos o "reply" da
checagem de erro, pois ele se refere apenas ao fastify, e
o fastify se refere a requisicao http, mas como ja falamos anteriormente, 
um usuario posteriormente pode ser criado nao por uma requisicao http, mas
por um sistema de messageria, ou uma integracao, etc.

entao essa checagem de email ja em uso, iremos apenas lancar um erro,

Essa funcao que fizemos chamamos de registerUseCase.

No Controller, agora sim, a gente apenas recebe os dados e devolve os dados.
sem precisar mexer com bcrypt ou prisma.

e como la lance um erro, a gente usa um try-catch.

 try {
    await registerUseCase({
        name, 
        email, 
        password
    })
} catch (error) {
    return reply.status(409).send()
}

se o controller chamou o register de caso de uso e deu um erro, nao tem problema,
a gente pega ali no catch.

(questao de mensagens de erro, ainda veremos mais pra frente uma forma melhhor
de lidar com isso.)


RESUMINDO: separamos a funcionalidade logica em si, da parte que eh especficia
da camada hhttp, ou seja, da camada de lidar com requisicao e resposta do nosso
framework (fastify.). Agora, em qualquer lugar da aplicacao podemos chamar o caso 
de uso de criar usuario mandando email, nome e senha. Nao precismaos nos preocupar 
em criar o usuario apenas quando for assim atraves de requisicao http


_______________________________


Repositoy Pattern

vamos tirar o codigo espeecifico de uma ferramenta(prisma) e colocar na pasta repositories. 
Apenas la vamos usar a logica do prisma e se comunicar com o banco de dados, pois vamos supor
que eu queira trocar o prisma por sequelize. Entao vms mexer apenas nessa pasta repositories. 

basicamente estamos protegendo nossa aplicacao de dependencias externas.

usamos a tipagem que o prisma gerou que serve para criiar um usuario, para poder
colocar como parametro, assim, nao precisamos denovo fazer a tipagem/interface pra
criar usuario (poderiamos separar em um arquivo essa interface tbm por exemplo.)


_____________________________

Inversao de Dependencia.

apesar do prisma estar totalmente desacoplado, o use-case de register continua dependente daquele repositorio.

oq vamos fazer eh, ao inves de instanciarmos o repositorio dentro do use-case, vamos receber ele por parametro.

isso vai ser bom pois, se quisermos trocar prisma pra sequelize, entao vamos ter que trocar a nomeclatura tbm
da instanciacao de todos os lugares que importamos esse repositorio.

Pra isso, nois entao nao vamos enviar ali no parametro diretamente, misturado com os outros parametros. 
Vamos envolver essa funcao em uma classe para podermos usar o construtor da classe. e sim, a classe tera
apenas um metodo.

a classe vai ter o mesmo nome da funcao, mas com o nome maiusculo. Entao, o nome da funcao vai ser algo mais generico, 
como handle ou execute.

no construtor vamos receber o repositorio. vamos chamar ele obviamente com um nome generico, pois pode vir 
prismaRepository, sequelizeRepository, qualquer coisa.

agora, a RESPONSABILIDADE de escolher o repositorio nao sera mais do use-case, mas sim, de que CHAMA-LO, que no caso,
eh o controller. La no controller, vamos instanciar o repositorio E instanciar a classe RegisterUseCase passando
aquele repositorio instanciado como parametro.
eai, eh so chamar essa classe + o metodo com os parametros normais. a classe ja ta com a dependencia injetada.


Resumindo: a inversao de dependencia fez com que: o arquivo que precisar do caso de uso, do register use case,
eh ele que vai enviar as dependencias como parametro. Agora o use-case nao vai ter nadica de nada relacionado ao prisma.
pois apesar do prisma ter sido desacoplado e colocado no repositorio, o use-case tbm tinha que instancia-lo, tinha
que se preocupar em pegar o repositorio correspondente, no caso, aquele do prisma.

__________________________

Precisamos de uma interface para se referir a qualquer repositorio.
Dessa forma, no construtor re RegisterUseCase, vai ficar usersRepository: UserRepository, ai inves de any
ou de PrismaRepository(que tbm estaria errado pois o use-case ficaria sabendo do prisma, ficaria dependente, 
e queremos nao ter nenhuma mencao do prisma, queremos apenas que esse use-case chame o repositorio, sem
precisar saber qual a implementacao concreta dele.)

Pra isso vamos usar uma interface (pode ser classe abstrata tbm.)

Com essa classe abstrata, todos os use-cases que chamarem repositorio vao esperar como parametro essa interface,
que corresponde a qualquer repositorio. Nessa interface, vamos colocar APENAS a assinatura do metodo, nao vamos 
implementa-lo. Dessa forma,  a interface determina que toda classe (repositorio no caso) que implementar ela, vai
precisar daquele metodo com aquele nome e com aquele tipo de parametro.

Com a interface criada, ele vai ser a tipagem do repositorio que cada use-case que chamar o repositorio vai esperar por parametro.

Dessa forma, o repositorio de users (prisma, sequelize, etc), tera que implementar (implements) essa interface

Podemos tbm criar uma pasta dentro da pasta repositorioes chamada prisma, e la colocamos todas as implementacoes
de repositorios que utilizam o prisma.

Eh a interface que eh o contrato, ela que vai decidir quais metodos vao existir na comunicacao
do repositorio com o caso de uso, quais os parametros e etc.



____________________________

A gente retorna erros no use-case, podemos retornar varios tipos de erros.

No controller, chamamos o use-case com um try-catch caso tenha erro. Mas no catch
retornamos apenas um reply.status com status do erro.

Mas pode ser varios erros, entao vamos criar uma pasta errors dentro da pasta use-cases e fazer classes pra todos os tipos de erros.
essa classe extende a classe Error nativa do js, chama o super(), que eh o construtor do Error, que eh o que estavamos
chamando anteriormente com throw new Error('xxx'), e colocamos a mensagem especifica ali.
Dessa forma, quando formos dar um throw error, vamos dar o throw na classe de erro correspondente.

la no controller, podemos fzr as condicionais p ver os erros e retornar o status correto, alem de recuperar a mensagem tbm.


_____________

La no app.ts, podemos fazer um handler global de erros, pra erros que a gente nao tratou ou pra erros que nao conhecemos.
la, colocamos condicional p erro de ZodError, e tbm fazemos log no erro pra caso estejamos rodando em ambiente de dev ou test.
Se for ambiente de producao, o log vai ser numa ferramenta externa de observabilidade.

e por fim, um erro generico 500, obviamente.


Dessa forma, caso aconteca um erro la no controller que nao capturamos nas condiconais  do catch, entao la mesmo depois das 
condicionais a gente faz um throw error, um throw no proprio error que veio no catch(error), dessa forma, deixamos pro
setErrorHandler do fastify pra lidar globalmente com esses erros, eh como se fosse uma pia. A gente joga os restos de comida
do prato fora, mas caso sobrar algo, mesmo assim nao vai descer no cano, pois tem uma rede ali no ralo pra pegar os restinhos
de comida por precaucao.


________________________

testes

npm i vitest -d
npm i vite-tsconfig-paths - pro vitest entender aqwueles paths q configuramos no tsconfiig

pra entender de fato, tem que colocar isso nos plugins la no vite.config.ts

fazer os scripts (vitest run eh so um, vitest sozinho eh tipo watch)

describre serve pra categorizar os testes que tiverem dentro dele

Comecando fazendo o teste de hash por exemplo, nois instanciamos o RegisterUseCase,
instanciamos tbm o prismaRepository, e chamamos a funcao execute. 
COmo saber se a senha foi hasheada? uma coisa interessante eh, nesses casos,
retornar o proprio usuario la nesse use-case, ai nois podemos, caso precisar,
pegar aquele usuario recem criado p fzer o q quiser, nesse caso, usar nos testes.
Retornar dentro de um objeto pois se no futuro a gente retornar outra coisa, nao 
vamos mudar a estrutura do retorno, seria so colcoar mais um atributo la dentro.
Isso eh bom obviamente pra evitar que a gente precise trocar tbm o jeito que pegamos o retorno caso
ja usamos em outro lugar anteriormente. tipo, eu pegava o user, agr vou ter q pegar dentro de um ojeto

(Nao esquecer de, depois de adicionar aquele retorninho, fazer a interface do response e 
tipar o retorno da funcao com Promise<interface>)

Com o user retornado, la nos testes podemos pegar ele de voltar pra usar a funcao
compare do bcryptsjs, que compara se tal senha corresponde aquele hash. No caso, 
comparamos a senha que usamos na hora de registrar chamando o execute, com o
user.password_hash do usuario retornado pelo metodo.

...Porem ha um problema. Estamos usando o prismaRepository, ou seja, estamos usando
o nosso banco de dados, e um teste unitario deve ser independente de qlqr camada.
queremos testar apenas se o registerUseCase.execute esta hasheando a senha, kct.
Entao, como fizemos a inversao de dependencia naquele use-case e ele nao depende da
implementacao, e sim da interface, da abstracao, entao podemos colocar ali um repositorio
fake. Podemos colocar um repositorio que implementa a interface que imita todas as funcoes 
normais, mas que sao feitas tudo na memoria, puro js. 

__________________
coverage - pra poder ver se a aplicacao ta sendo bem testada 

npm i @vitest/coverage-c8

"test:watch": "vitest",
"test:coverage": "vitest run --coverage"

eai com isso a gente abre o file explorer, la da pra ver quais linhas do codigo nunca foram rodadas,
e quantas vezes foram rodadas, etc.

_______________
vitest ui 
iinterface p visualizar melhor os testes - abre um navegador

@vitest/ui"


__________________________________

authenticate - use case

Vamos fazer mais funcionalidades. Vamos comecar pelo caso de uso pois ele ja eh testavel desde o iinicio com
testes unitarios

caso de uso de autenticacao.
 - classe AuthenticateUseCase com seu construtor com o UserRepository
 - o metodo unico execute
 - iinterface de request e response


no use-case de authenticate, foi feito recebido por parametro o usuario, foi checado se ele
existe, depois foi checado se a senha esta correta. Ambos os erros possiveiis retornamos o 
mesmo (invalid credentials), pois nesses casos de authetnciacao, nao eh bom falar p usuario qual
foi o erro especifico, por seguranca.

Depois que foi feito esse caso de uso de autenticacao, vamos fazer o teste e o controller dele.

___________________________________

authenticate - testes e controller

Sera feito teste para verificar se , ao criar um usuario e authentica-lo, se um user.id eh
criado. 

tambem sera feito testes para verificar os erros, forcando a entrar nos ifs de erros

Repare que para criamos um usuario fake, basta chamarmos o metodo create do usersRepository,
que basicmaente cria um usuario na array de items, pois eh assim que foi feito o repositoruio
fake para salvar as coisas em memoria. um user mockado !

Agora que foi feito os testes do use-case, podemos fazer o controller.

Assim como no controller de register, validamos o request com zod, chamamos 
o use-case e enviamos uma response.

Repare que no controller a gente faz validacao com zod de forma mais incisiva, tipo,
regra(email.cpf,etc), minimo de caracteres. Ou seja, validando o request do frontend mesmo.

ja no use-case sim ha a tipagem com interface, apenas para tipar o request e response

e pronto, podemos criar a rota nomeando com session e chamando o controller correspondente.

Repare que a autenticacao ta bem pobre, apenas estamos validando o email e senha do usuario.
Porem tbm temos que validar o usuario nas suas proximas requisicoes dentro da aplicacao.
Pra isso, no futuro, usaremos jwt p usar tokens

_____________________________________

Uma regra dos testes unitarios eh que cada teste deve ter seu contexto totalmente isolado. Por isso
que, em cada teste, eh instanciado um repositorio do "zero".

Se instanciarmos esse repositorio la em cima no describe ou fora do escopo, todos os testes vao misturar 
os contextos, e testes unitariios nao podem acontecer isso.

Entao, vamos usar o beforeEach para inciializar o repositorio e o use-case uma vez antes
de cada teste.

Entao la em cima fica let usersRepository: InMemoryRepository e let sut: AUthenticateUSeCase ou RegisterUseCase.
dessa forma, criamos e tipamos.
dentro do beforEACH, ai sim vms atribuir corretamente


_______________________________________________

para evitar que toda vez que formos chamar um use-case, ter que instanciar todas as suas dependencias,
entao vamos fazer uma funcao que ja fazz isso automaticmaente e de forma centralizada

FACTORY PATTERN !!

Agora, quando formos alterar alguma dependencia, tirar ou adicionar, eh so mexer ali no factory que
ja vai refletir em todos os lugares.

entao esse factory serve so pra instanciar mesmo as classes/entidades. Nao tem regras de negocio.

_____________________________________________

caso de uso - PERFIL

id eh a informacao que nunca vai ser alterada, entao o use case de perfil vai receber ela como parametro
para poder recuperar os dados do usuario

ha de criar a assinatura do metodo findById na interface do repositorio de usuario.
ha de implementar nos repositorios que a implementam, no in memory e no prisma.

vamos primeiro fazer todos os use-cases com seus testes unitarios, e depois vamos fazer os conmtrolers e seus testes maaiores

eh mt comum fazermos a verificacao de existencia daquele usuario/id, e raramente esse erro tbm vai acontecer, entao
sera feito um error generico (resource not found)

Vamos focar bastante primeiros nos casos de uso sem se preocupar com os factorys e controllers. Os casos de uso nao
dependem de nada externo, entao eh como se estivessemos preparando o core da aplicacao, criando primeiro a base de tudo, pra
depois ir pra camada de infra, implementar de fato as coisas que se comunicam com o externo, como a camada http, o prisma, o banco, etc.

____________________________________________

caso de uso - CHECK-IN

fazer o check-in use case, fazer a interface de checkinsRepository, e depois implementar o in memory p repository,
inicialmente com o metodo create.

use case vai receber por construtor esse repositorio novo de checkin.

______________________________________________________

TDD 

desenvolvimento dirigido a testes - se desenvolvermos o teste de uma regra de negocio antes da implementacao daquilo, 
o teste por si so ajuda a validar se sua implementacao esta certa.

eh metodologia, entao eh opcional. pode usar ou nao, pode ser util ou nao, pode ser bom p alguem ou nao.

eh bom a gente fazer isso em alguma funcionalidade mais complexa...crud simples pode fzr os testes dps mesmo.

fluxo do tdd - red, green, refactor
red- causo o erro (no inicio, com nada implementado, obvio que vai dar erro)
green - codamos o minimo possivel p solucionar o erro, p  qndo dar test, dar certo
refactor - refatoramos.

smp q possivel, nosso teste unitario deve ser o mais especifico possivel.

eh melhor ter varios testes que testam pequenas partezinhas do que um teste nosso
testar mais casos


Mocking - criar valores ficticios pra dados.

Vamos usar essa estrategia pois lidar com datas em testes pode ser problematico

Red (Vermelho): 
nesta fase, o desenvolvedor escreve um teste que deve falhar, ou seja, ele garante que o teste não passará sem implementar o código necessário.

Green (Verde): 
aqui, o desenvolvedor escreve a quantidade mínima de código necessária para fazer o teste passar.

Refactor (Refatorar): 
após o teste passar, o desenvolvedor refatora o código para melhorar a qualidade, sem alterar seu comportamento.

REGRA DE NEGOCIO DO CHECK-IN 
Usuario nao pode fazer 2 checkins no mesmo dia.

Pra isso, vamos nesse caso usar o metodo TDD. 

os testes serao de criacao de checkin, e depois validar que dois checkins nao podem ser feitos
no mesmo dia.

o teste de dois checkins no mesmo dia, sera feito um teste que ira falhar, pois nao implementamos nada ainda.

No caso, a criacao de dois checkins no mesmo dia deve dar reject.toBeInstanceOf(Error)

deu RED. 

Vamos fazer dar green do jeito mais simples possivel (e errado)

Vamos criar mais um metodo no repositori (alem do create) chamado findbyUserOnDate, ou seja
procurar por um usuario EM uma data.

Nesse metodo, vamos resolver o teste de maneira porca. vamos simplesmente verificar se aquele 
usuario ja fez checkin antes. Ou seja, nao estamos usando a data ainda.

pronto, o teste que busca rejeicao em caso de chheckin no mesmo dia ja esta dando certo.

No teste, usamos 
vi.setSystemTime(new Date(2022, 0, 20, 8, 0, 0))
para mockar uma data.

Agr vamos fzr um teste que tem que deixar um usuario fazer checkin em dias diferentes.

Setamos uma data em uma criacao de checkin, dps setamos OUTRA data antes da criacao
de outro checkin, pra contar como checkins em dias diferentes. Esperamos que de certo ne? 
pois bem, nao deu, pois la no repositorio apenas estamos validando de acordo com o userId, e nao
com a data.

Entao tdd eh isso. Fizemos o teste passar de qualquer jeito. Depois, vou criando mais testes 
pra dar mais erros, e ir nos ajudando a entender pra onde temos que caminhar.

Isso foi maravilhoso!!!!!!!!!!!!!!!!!!! 
usuario nao pode fazer 2 checkins no mesmo dia! fizemos um teste simples que falhou. depois
resolvemos com uma implementacao simples. Usuario PODE fazer 2 checkins em dias diferentes!
fazemos o teste e falhou, pois a nossa implementacao basica anterior nao foi o suficiente. Entao
fazemos mais uma implementacao pra validar esse proximo teste.

Voce vai criando testes e mais testes pra cada uma das possibilidades de fluxo que o usuario pode fzr.

_____________________ 

continuando a testar e implementar os checkins

No metodo de findByUserOnDate, tambem precisamos levar em conta a data, alem do usuario. Nosso ultimo teste
esta falhando pois nao esta deixano o usuario fazer 2 checkins em dias diferentes, pois estamos implementando
o suficiente apenas para suprir o teste anterior, rejeitando a criacao de checkin caso um usuario ja tenha feito, 
mas sem levar em conta a data. Agora que fizemos um teste que precisa deixar que o usuario faca checkins em dia 
diferentes, entao PRECISAMOS levar em conta a data tbm pra satisfazer esse teste.

Entao, la no repositorio em memoria, so pra testes, vamos implementar essa nova necessidade. 

Sabendo que pra gente fazer esse findByUSerOnDate, temos que verificar tanto o user quando a data
usando aquele array de itens, entao vms ter que percorrer aquele array, e em cada elemento, verificar
se aquele checkin eh do usuario. ALem disso, verificar se a data daquele checkin daquele usuario, corresponde
ao dia atual. Se essas duas condicoes for true, entao o booleando de chehckInOnSameDate sera true, logo,
verificamos se tem ou nao um checkin daquele usuaro naquele dia.

Com a biblioteca dayjs, foi criado uma variavel que pega o valor do inicio do dia, e outra variavel
pra pegar o valor do final do dia.
Agora, alem de retornar bool no caso de JA TER, no array de itens, um checkin daquele userId que foi passado por parametro, tbm vamos jogar bool se
esse checkin da iteracao corresponder a antes do fim da data atual e depois do inicio da data atual, data atual essa que foi passada por parametro.

+ logicas...

O checkin so pode ser feito se o usuario estiver pelo menos 100m de distancia da academia.

no use-case de checkin entao, temos que trabalahr com entidade de academia, pois eh nela que estao armazenados
latitude e longitude.
Entao temos que criar um repositorio pra academias para poder buscar academias do banco.

Pra sabermos a distancia entre o usuario e a academia, tbm devemos ter a latitude e longitude do usuario.

Entao ja colocamos esses dados na interface de request. Como vamos buscar esses dados? isso vms ver dps, o importante
eh colocar ali que vms ter esses dados. Ate por que, o caso de uso NAO PRECISA SABER DE ONDE AS INFORMACOES VEM. lembremos
que caso de uso eh a parte mais isolada do resto da aplicacao, eh onde nao ha dependencia de nada. os dados ela vai receber do controller, 
as dependencias tbm, etc. O que importa eh que o caso de uso tem que receber essas informacoes que sao necessarias pra ele funcionar.

Entao vms atribuir essas informacoes na interface de request, vms tbm colocar mais uma dependencia na classe, a dependencia de gymRepository,
e tbm vms criar o metodo de buscar o gym pelo id la no repositorio in memory que extende o gym repository interface

tbm ja vamos adiantar o erro de gym nao encontrado, com aquele erro padrao que fizemos anteriormente de resourceNotFound

Agora vamos partir pro calculo de distancia, onde obviamente iremos tbm retornar outro erro no caminho triste.

Porem, ja que mudamos a interface de request, tbm mudamos o tipo de request da rota, e ja que mudamos tbm as dependencias, entao
isso tbm devera influenciar os testes. 
La no testes, vai estar com erro pois o use-case de checkin vai precisar de duas dependencias
Nas chamadas dos executes, tbm vms ter que adaptar ao novo request...tera latitude e longitude
(lat e lon so vao ser importantes nos testes que estarao checando algo relacionado a distnacia, ent passa como 0 alguns)
Tbm sera necessario criar uma gym em cada teste, pois agora, nosso use-case tbm ta comecando a lidar com o gymId, nao so com
o userId. Tanto que ate ta com erro de notfoundresource pra gym, pois precisamos dela p calcular a distancia.

Caso ainda nao tivermos o metodo no repositorio de criar gym, entao podemos simplesmente adicionar uma gym no array de items do 
repositorio, nao tem problema fzr isso las nos testes, ate pq no repositorio in memory de gym seria assim mesmo que iriamos criar
uma gym, adicionando ela no array de items.



Vamos fazer o teste para validar a distancia entre o usuario e a academia.

fazendo checkin em uma academia longe, claro que o teste nao vai funcionar, pois
era pra dar reject, mas ainda nao implementamos a logica.

entao, vamos pegar as coordenadas do gym que pegamos pelo repository e as coordenadas do usuario que
vem por parametro. Fazer a funcao de calculo de distancia na pasta Utils e enviar os dados. 
Nao esquecer de pegar o retorno e fzr condicional com a distancia requerida(100m)

_____________________________________
use case de criar academia.

fazer a assinatura na interface repository
fazer a implementacao no in memory repository
fazer o use-case - call repository, do interfaces(req & res), dependencies.
testes.

coisas a cuidar: 
-prisma nao aceita tipo undefined;
-new Decimal
-precisamos de testes que criam gyms com id especifico,
entao, ha de verificar-se o repositoryo de gym pra ver
se a atribuicao do ID esta correta ( criar uuid apenas
se nao data.id for null) (Pois estavamos criando uma gym
com id especifico usando o metodo create, mas no create 
estavamos criando o gym semrpe  com id aleatorio, sem antes
verificar se ha um id no data.)

___________________________
use-case historico (lista de checkins)

- fazer a assinatura na interface repository
- fazer a implementacao no in memory repository
- fazer o use-case - call repository, do interfaces(req & res), dependencies.
- testes.

nos testes, vamos criar alguns checkins, os dois em gyms diferentes, 
ou seja, com gym ids diferentes.

no test, ao criar esse checkin levando em conta o gym id e obviamente o id do usuario, 
vamos esperar que, ao chamar o use-case com o findManyCheckins, venha a quantidade
predefinida e que os objetos contenham tal campo (os gym ids), ao inves de desneces-
sariamente colocar o ojeto inteiro.

na paginacao, vms fazer um loop p criar varios checkins e, ao retornar eles com o findMany,
vms esperar que retorne a sobra da primeira apginacao.
Por exemplo, temos 22 checkins, vms fzr paginacao de 20 items. Entao vms pegar todos os 
checkins com o findmany, colocar pra buscar a pagina 2, e esperar, alem de 2 itens,
tbm os objetos contendo seus respectivos ids (gym_21 e gym_22)

Como paginar? antes, estavamos pegando todos os checkins de determinado usuario, usando o 
filter (p pegar apenas os items daquele array em que o user_id do item seja igual ao userId
que veio por parametro). Agora, vamos tambem pegar esse resultado e usar o metodo .slice, que 
pega uma fatia da lista resultante. do index x ao index y.

pagina 1 - slice(0, 20)
pagina 2 - slice(20, 40)

entao, como a pagina tbm vem por parametro, vai ser o seguinte:

(page * 20, page * 20) - errado, pois a primeira pagina eh a pagina 1,
entao a primeira parte ficaria 20 ao inves de 0.
entao = slice.((page - 1) * 20, page * 20)

Dessa forma, a cada troca de pagina, o parametro "page" muda, entao automaticamente
ja retorna a nova fatia.

________________________________________

Depois de fzr todos os use-cases, podemos ir pra parte da infraestrutura,
os controllers, as rotas, os repositorios (prisma no caso), ou seja, tudo
que eh volatil, que pode mudar no futuro.

Agora vamos expor a nossa apliccacao ao mundo, pois ate agr, todos os testes
que a gente fez, os casos de uso, apesar de validarmos, eles funcionam
a nivel de codigo, mas nao sao acessiveis, nao tem ccontrollers, rotas,
nao tem repositorio do prisma, etc.

Agora vms pras camadas externas. Uma expressao comum, nossa aplicaccao eh dividida
em camadas literalmente.

Os casos de uso, que tem as regras de negocio, eh a coisa mais importante da aplicacao,
e deixamos ela pronta antes de todo o resto. Esse ehh o core da aplicacao, nao pode
deixar de funcionar, nao pode faltar testes.

Vamos entao comecando implementando os repositorios do prisma.

repositorio de checkin...

Repare que eh uma tarefa rapido, so precisa conheccer das nuances do prisma no caso.
os tipos dos parametros e os retornos ja estao definidos, eh so fazer.

repare que pra buscar o checkin ccom base no userId e na data (createdAt),
nois nao vamos reccuperar todos os checkins e fzr o filtro, vamos filtrar
pelo proprio prisma mesmmo. Como queremos filtrar por uma condicao que nao eh "unica", como 
o id ou email, e sim pela data de criacao, entao vamos usar o findFirst, e nao o findUnique.
nisso, usamos o greaterThanOrEqual e lessthanOrEqual para verificar se a data de criacao
esta entre a data que veio por parametro. Pra isso, tbm usamos o dayjs pois so queremos
comparar os dias, sem ligar pras horas minutos e segundos.


repositorio de gym...

no caso do findManyNearby, no repositorio em memoria, como eh tudo js, usamos na propria busca
uma funcao js que fizemos apra filtrar com base na longitude e latitude.
Porem, o prisma nos da facilidade nessas coisas simples, criacao, exclusao, busca, etc.
mas nesse caso mais especifico, o vamos precisar usar sql puro para executar aquela query 
que filtra pela localizacao. 

Usamso o generics para tipar o retorno pois o prisma nao sabe ler o que tamo fazendo naquele queryRaw.

Assim como no caso da funcao js p caclualr a distancia entre gym e usuario, nois tbm obviamente pegamos
da internet aquela query pronta. 


__________________________________

criar as factories pra TODOS os casos de uso, pois cada caso de uso pode ter multiplas dependencias, sendo assim,
quando usarmos esse caso de uso, ja temos ele pronto.

_______________________________________________


Estrategias de autenticacao

basic auth - todas as requisicioes, o usuario precisa enviar as credenciais dele
no cabecalhho da requisicao.
Cabecalho sao metadados da requisicao e da resposta, nao sao dados que ele vai inserir,
sao dados de contexto geralmente.

Existe um header chamado Authorization, pra autenticacao.

No basic auth, a gente enviaria nesse header o Basic (do basic auth),
e em seguida as credenciais, como o email e senha, e em formato abse 64

jwt - mais famoso - json web token
user faz login - envia email e senha, backend cria um token unico, n modificavel e stateless.
stateless - nao eh armazenado em qualquer estrutura de persistencia de dados (banco de dados)

o token eh criado a partir de uma palavra chave, que apenas a api sabe. entao so a nossa api vai conseguir decodificar 
aquele token criado por ele mesmo. sendo assim, so a nossa api vai cconseguir recuperar os dados dentro daquele token,
(headers, payload, signature)

ok, entao o backend sabe se aquele jwt foi criado por ele mesmo. 
mas como vai saber qual eh o usuario q enviou aquilo? nois botamos o id do usuario dentro do token,
geralmente dentro do 'sub' do payload.

ta, mas e se eu mandar um id diferente? hahahah! a assinatura tbm vai mudar, e eh isso que o backend vai validar.
qualquer informacao que mandamos pro payload, a assinatura muda tbm. Ou seja, se mandar um id esquisito, o 
ackend vai ler a assinatura e ver que nao foi ele quem criou aquela assinatura.

vms enviar esse jwt em todas as requisicoes que precisam ser autenticadas, a diferenca eh que nao vamos usar
o formato Authorization: Basic, mas sim, o Authorization: Bearer, que eh a terminologia pra qnd enviarmos um jwt p
autenticar a requisicao.

_____________________

BOM SAber que jwt geralmente eh 99% usado pra front se comunciar com back com protocolo http.
Se for outro tipo de comunicacao, tipo se comunicar com uma outra aplicacao externa, tem tm varias
 estrategias, como OAuth, API tokens, etc.

Entao, essa nossa autenticacao jwt so servira pra camada http, ali nos controllers e rotas. Os casos de uso eh camada 
mais pura da nossa aplicacao e que nao quer saber se eh o front que ta chamando, o mobile, uma aplicacao externa, entao
vai ter nada de jwt por la.

npm i @fastify/jwt

vamos registrar esse modulo jwt.

no app.ts, vms entao registrar esse modulo e passar o 'secret', porem melhor ficcar dentro de .env, 
pra nem a nossa equipe ter acesso a tela.

Quando registramos isso, agr temos novos metodos disponiveis nas nossas rotas.

O que queremos eh: no processo de login, queremos gerar e devolver pro front um jwt. Atualmente apenas esta
fazendo o login e validando o email e senha. 

Vejamos que no caso de uso de autenticacao, ha a validacao do email e senha. Entao, no controller, quando chamarmos
esse use-case, vms armazenar o usuario, pois la no use-case, o usuario eh retornado.

com o usuario 'autenticado' ou seja, com email e senha corretas, vms entao criar um jwt nesse ccontroller.
Como registramos o jwt no fastify, temos acesso a novos metodos no request e reply. No reply, temos o jwtSign()
que serve exatamente p criar um novo token. 1 param - payload - informacoes adicionais.
o id, no caso, coloccamos no segundo parametro, no sign: { sub: user.id}

Nao podemos colocar informacoes sigilosas no jwt como email ou senha, pois o jwt nao eh criptografado, apenas
eh codificado.

Apos criar o token, podemos retornar. 

curiosidade - no imnsonia, podemos facilmente injetar o toke nali em auth -- bearer.
mas eh a mesma coisa que irmos em headers, colocarmos Authorization - Bearer e depois o token.

queremos autenticar o token e saber qual eh o usuario que ta chamando tal rota...
Se chamarmos qualquer rota, por exemplo a rota profile, e passarmos esse token, caso a gente
de um console.log(request.headers). E ai, quando fazemos a requisicao, esse console eh lido e exibe
no terminal o header da requisicao, e aparece la o authorization com o Bearer + o token.

De dentro desse token, precisamos VALIDAR que eh token gerado pela nossa aplicacao, e tbm precisamos
buscar os dados que estao contidos dentro desse tokenn

await request.jwtVerify() essa funcao busca o token no cabecalho. se existe, verifica se foi gerado
realmente pela nossa aplicacao.

eai, eh so pegar no request.user.sub.

__________________________________

middleware para autenticacao.

Em todas as requisicoes que precisam swer autenticadas, precisamos entao chamar esse request.jwtVerify.
Entao vms automatizar isso, chamar um middleware la na hora de chamar a rota.











